{
  "language": "Solidity",
  "sources": {
    "contracts/Voting.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/utils/Strings.sol';\n\n/** \n * @title Alyra Project: Voting system\n * @author Teddy Chambard\n * @notice This contract defines a basic voting system including different steps:\n * 1) voting session creation\n * 1) voters registration\n * 2) proposals registration\n * 3) votes recording\n * 4) votes talling\n * \n * @dev Only the contract owner is able to create new voting session.\n * The contract owner is also able to change the session status and activate next session steps.\n * The word `Administrator` in contract documentation corresponds to contract owner.\n *\n * /!\\ BONUS: I took some decisions to change initial specifications to improve the features available in the exercice:\n *\n * 1) Many voting sessions can be created and evolve in parallel\n * 2) Votes are kept secret until the end of session, then every votes become accessible to voters and contract owner\n * 3) Every events expose sessionId as first parameter\n * 4) `Voted` event does not expose chosen proposal ID in order to keep votes secret until the end of the session\n * 5) A session is limited to 256 proposals\n * 6) Two proposals are registered by default in every session: abstention and blank vote\n * 7) A voter can not do more than 3 proposals by session\n * 6) A voter can not vote for its own proposals\n * 7) A vote session can terminate with equality if many proposals obtain same number of votes\n */\ncontract Voting is Ownable {\n\n    // ===============\n    // types\n    // ===============\n\n    enum WorkflowStatus {\n        None,\n        RegisteringVoters,\n        ProposalsRegistrationStarted,\n        ProposalsRegistrationEnded,\n        VotingSessionStarted,\n        VotingSessionEnded,\n        VotesTallied\n    }\n\n    struct Voter {\n        bool isRegistered;\n        bool hasVoted;\n        uint8 votedProposalId;\n        uint8 nbProposals;\n    }\n\n    struct Proposal {\n        string description;\n        uint voteCount;\n        address proposer;\n    }\n    \n    struct Session {\n\n        /**\n         * @dev status is set to RegisteringVoters by createVotingSession function.\n         * The inilial value `None` does not match with any expected status used with `isStatus` modifier.\n         * Note: every functions are covered by `isStatus` modifier and that's why we can be sure a \n         * session exist when its status is different than None.\n         */\n        WorkflowStatus status;\n\n        /**\n         * !!! WARNING !!!\n         * I decided to change a little the specifications to give more sense to the voting project:\n         * \n         * Initial specifications were :\n         * ✔️ Le vote n'est pas secret pour les utilisateurs ajoutés à la Whitelist\n         * ✔️ Chaque électeur peut voir les votes des autres\n         *\n         * @dev In my implementation, voters mapping is never accessible from external so voter's choice (votedProposalId) \n         * is not known until `getVote` become available after end of voting session.\n         * Informations like `isRegistered`, `hasVoted` or `nbProposals` are still available trough events.\n         */\n        mapping(address => Voter) voters;\n\n        /**\n         * @dev Voters count will be used to compute abstention\n         */\n        uint votersCount;\n\n        /**\n         * @dev Total votes count can be different than voters count and it will be used to compute abstention.\n         */\n        uint totalVotesCount;\n\n        /**\n         * @dev proposals are not available directly to protect `voteCount` information during voting process.\n         * However, informations like `description` or `proposer` are still available trough events.\n         */\n        Proposal[] proposals;\n\n        /**\n         * winningProposals can be retrive after votes tallied with the function `getWinners`\n         */\n        Proposal[] winningProposals;\n    }\n\n    // ===============\n    // events\n    // ===============\n\n    /**\n     * !!! WARNING !!!\n     * @dev All events signatures integrate sessionId parameter that was not required in specification\n     */\n\n    event SessionCreated(uint indexed sessionId, string name, string description);\n\n    event VoterRegistered(uint indexed sessionId, address voterAddress);\n\n    event WorkflowStatusChange(uint indexed sessionId, WorkflowStatus previousStatus, WorkflowStatus newStatus);\n\n    /**\n     * !!! EDIT !!!\n     * @dev I decided to add proposer and description into ProposalRegistered event in order to give to the dapp the capability to list proposals only with events.\n     */\n    event ProposalRegistered(uint indexed sessionId, uint8 proposalId, address proposer, string description);\n\n    /**\n     * !!! EDIT !!!\n     * @dev To follow feedbacks given on project #1, I decided to revert my decision about removing proposalId from Voted event despite the specification.\n     */\n    event Voted(uint indexed sessionId, address voter, uint proposalId);\n\n    event VotesTallied(uint indexed sessionId, uint votersCount, uint totalVotes, uint blankVotes, uint abstention, Proposal[] winningProposals);\n\n    // ===============\n    // storage\n    // ===============\n\n    mapping(uint => Session) private sessions;\n\n    uint sessionsCount;\n\n    // ===============\n    // modifiers\n    // ===============\n\n    /**\n     * @dev Throws if called when status is not the expected one.\n     * !!! EDIT !!! I simplified revert messages\n     */\n    modifier statusIs(uint _sessionId, WorkflowStatus _status) {\n        require(sessions[_sessionId].status == _status, 'bad status');\n        _;\n    }    \n    \n    /**\n     * @dev Throws if called when status is not at least the given status.\n     * !!! EDIT !!! I simplified revert messages\n     */\n    modifier statusAtLeast(uint _sessionId, WorkflowStatus _status) {\n        require(sessions[_sessionId].status >= _status, 'bad status');\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account not registered as voter.\n     * !!! EDIT !!! I simplified revert messages\n     */\n    modifier onlyVoter(uint _sessionId) {\n        require(sessions[_sessionId].voters[msg.sender].isRegistered, 'not voter');\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account not registered as voter or if it is not owner.\n     * !!! EDIT !!! I simplified revert messages\n     */\n    modifier onlyVoterOrOwner(uint _sessionId) {\n        require(owner() == msg.sender || sessions[_sessionId].voters[msg.sender].isRegistered, 'not owner or voter');\n        _;\n    }\n\n    // ===============\n    // only owner functions\n    // ===============\n\n    /**\n     * Administrator can create new voting session\n     *\n     * @param _name The session name \n     * @param _description The session description \n     */\n    function createVotingSession(string calldata _name, string calldata _description) external onlyOwner {\n        sessions[sessionsCount].status = WorkflowStatus.RegisteringVoters;\n        emit SessionCreated(sessionsCount, _name, _description);\n        emit WorkflowStatusChange(sessionsCount, WorkflowStatus.None, WorkflowStatus.RegisteringVoters);\n        sessionsCount++;\n    }\n\n    /**\n     * Administrator can register voters.\n     * \n     * @dev voters can be added only by contract owner when status is set to RegisteringVoters\n     * An event VoterRegistered is emitted\n     * \n     * @param _sessionId The session identifier \n     * @param _voter The address to add into voters registry\n     */\n    function registerVoter(uint _sessionId, address _voter) external onlyOwner statusIs(_sessionId, WorkflowStatus.RegisteringVoters) {\n        require(_voter != owner(), 'can not be a voter');\n        require(!sessions[_sessionId].voters[_voter].isRegistered, 'already registered');\n        sessions[_sessionId].voters[_voter] = Voter(true, false, 0, 0);\n        sessions[_sessionId].votersCount++;\n        emit VoterRegistered(_sessionId, _voter);\n    }\n\n    /**\n     * Administrator can close voters registration and open proposals registration.\n     * \n     * @dev Can be called only when status is set to RegisteringVoters.\n     * Two default proposals are registered at the beginning of this step: `Abstention` and `Blank`.\n     * That means a registered voter that forget to vote will be counted as `abstention` thanks to `proposals` array index 0\n     * An event WorkflowStatusChange is emitted\n     *\n     * @param _sessionId The session identifier \n     */\n    function startProposalsRegistration(uint _sessionId) external onlyOwner statusIs(_sessionId, WorkflowStatus.RegisteringVoters) {\n        _registerProposal(_sessionId, 'Abstention');\n        _registerProposal(_sessionId, 'Blank');\n        sessions[_sessionId].status = WorkflowStatus.ProposalsRegistrationStarted;\n        emit WorkflowStatusChange(_sessionId, WorkflowStatus.RegisteringVoters, WorkflowStatus.ProposalsRegistrationStarted);\n    }\n\n    /**\n     * Administrator can close proposals registration.\n     * \n     * @dev Can be called only when status is set to ProposalsRegistrationStarted.\n     * An event WorkflowStatusChange is emitted\n     *\n     * @param _sessionId The session identifier \n     */\n    function stopProposalsRegistration(uint _sessionId) external onlyOwner statusIs(_sessionId, WorkflowStatus.ProposalsRegistrationStarted) {\n        sessions[_sessionId].status = WorkflowStatus.ProposalsRegistrationEnded;\n        emit WorkflowStatusChange(_sessionId, WorkflowStatus.ProposalsRegistrationStarted, WorkflowStatus.ProposalsRegistrationEnded);\n    }\n\n    /**\n     * Administrator can open voting session.\n     * \n     * @dev Can be called only when status is set to ProposalsRegistrationEnded.\n     * An event WorkflowStatusChange is emitted\n     *\n     * @param _sessionId The session identifier \n     */\n    function startVotingSession(uint _sessionId) external onlyOwner statusIs(_sessionId, WorkflowStatus.ProposalsRegistrationEnded) {\n        sessions[_sessionId].status = WorkflowStatus.VotingSessionStarted;\n        emit WorkflowStatusChange(_sessionId, WorkflowStatus.ProposalsRegistrationEnded, WorkflowStatus.VotingSessionStarted);\n    }\n\n    /**\n     * Administrator can close voting session.\n     * \n     * @dev Can be called only when status is set to VotingSessionStarted.\n     * An event WorkflowStatusChange is emitted\n     *\n     * @param _sessionId The session identifier \n     */\n    function stopVotingSession(uint _sessionId) external onlyOwner statusIs(_sessionId, WorkflowStatus.VotingSessionStarted) {\n        sessions[_sessionId].status = WorkflowStatus.VotingSessionEnded;\n        emit WorkflowStatusChange(_sessionId, WorkflowStatus.VotingSessionStarted, WorkflowStatus.VotingSessionEnded);\n    }\n\n    /**\n     * Administrator can trigger votes talling.\n     * \n     * @dev After votes talling, it is possible that we got many winning proposals.\n     * Votes talling can be triggered only by contract owner when voting session status is set to VotingSessionEnded\n     * An event WorkflowStatusChange is emitted\n     *\n     * @param _sessionId The session identifier \n     */\n    function tallyVotes(uint _sessionId) external onlyOwner statusIs(_sessionId, WorkflowStatus.VotingSessionEnded) {\n        uint _bestVoteCount = 0;\n        uint _winnersCount = 0;\n        \n        // use memory here to not write too many times in storage in the first loop below\n        // not sure it's better because of static array size\n        Proposal[] memory _winningProposals = new Proposal[](sessions[_sessionId].proposals.length);\n\n        // we do not consider two first proposal elements (abstention and blank)\n        for (uint i = 2; i < sessions[_sessionId].proposals.length; i++) {\n            if (sessions[_sessionId].proposals[i].voteCount > _bestVoteCount) {\n                _bestVoteCount = sessions[_sessionId].proposals[i].voteCount;\n                _winnersCount = 1;\n                _winningProposals[_winnersCount - 1] = sessions[_sessionId].proposals[i];\n            } else if (sessions[_sessionId].proposals[i].voteCount > 0 && sessions[_sessionId].proposals[i].voteCount == _bestVoteCount) {\n                _winnersCount++;\n                _winningProposals[_winnersCount - 1] = sessions[_sessionId].proposals[i];\n            }\n        }\n\n        for (uint i = 0; i < _winnersCount; i++) {\n            sessions[_sessionId].winningProposals.push(_winningProposals[i]);\n        }\n\n        sessions[_sessionId].status = WorkflowStatus.VotesTallied;\n        emit WorkflowStatusChange(_sessionId, WorkflowStatus.VotingSessionEnded, WorkflowStatus.VotesTallied);\n\n        uint abstention = sessions[_sessionId].votersCount > 0 ? sessions[_sessionId].votersCount - sessions[_sessionId].totalVotesCount : 0;\n        emit VotesTallied(_sessionId, sessions[_sessionId].votersCount, sessions[_sessionId].totalVotesCount, sessions[_sessionId].proposals[1].voteCount, abstention, sessions[_sessionId].winningProposals);\n    }\n\n    // ===============\n    // only voter functions\n    // ===============\n\n    /**\n     * A voter can register a new proposal.\n     * \n     * @dev Each voter can register many proposals.\n     * As the vote is considered to be done in small organization context, the maximum number of proposals is limited to 256.\n     * Maximum number of proposals per voter is also limited to 3.\n     * A vote can be added only by registered voter when status is set to VotingSessionStarted\n     * \n     * @param _sessionId The session identifier\n     * @param _description The proposal description\n     */\n    function registerProposal(uint _sessionId, string calldata _description) public onlyVoter(_sessionId) statusIs(_sessionId, WorkflowStatus.ProposalsRegistrationStarted) {\n        require(sessions[_sessionId].voters[msg.sender].nbProposals < 3, 'max 3 proposals');\n        _registerProposal(_sessionId, _description);\n    }\n\n    /**\n     * A voter can register his vote for a proposal.\n     * \n     * @dev Each voter can vote only once for one proposal.\n     * Votes can be added only by registered voter when status is set to VotingSessionStarted\n     * \n     * @param _sessionId The session identifier\n     * @param _proposalId The chosen proposal identifier\n     */\n    function vote(uint _sessionId, uint8 _proposalId) external onlyVoter(_sessionId) statusIs(_sessionId, WorkflowStatus.VotingSessionStarted) {\n        require(!sessions[_sessionId].voters[msg.sender].hasVoted, 'already voted');\n        require(_proposalId < sessions[_sessionId].proposals.length, 'not found');\n        require(_proposalId > 0, 'abstention forbidden');\n\n        sessions[_sessionId].proposals[_proposalId].voteCount++;\n        sessions[_sessionId].voters[msg.sender].hasVoted = true;\n        sessions[_sessionId].voters[msg.sender].votedProposalId = _proposalId;\n        sessions[_sessionId].totalVotesCount++;\n        \n        emit Voted(_sessionId, msg.sender, _proposalId);\n    }\n\n    // ===============\n    // only owner or voter functions\n    // ===============\n\n    /**\n     * Retreive vote\n     * \n     * @dev Administrator and registered voters can all access to everybody votes but only at the end of voting session.\n     * \n     * @param _sessionId The session identifier\n     * @param _voter The voter address\n     * @return uint8 target voter proposal choice\n     */    \n    function getVote(uint _sessionId, address _voter) external view onlyVoterOrOwner(_sessionId) statusAtLeast(_sessionId, WorkflowStatus.VotingSessionEnded) returns (uint8) {\n        return sessions[_sessionId].voters[_voter].votedProposalId;\n    }\n\n    /**\n     * Retreive winning proposals\n     * \n     * @dev Administrator and registered voters can retreive winning proposals but only at the end of voting session.\n     * \n     * @return Proposal[] The winning proposals\n     */    \n    function getWinners(uint _sessionId) external view onlyVoterOrOwner(_sessionId) statusAtLeast(_sessionId, WorkflowStatus.VotesTallied) returns (Proposal[] memory) {\n        return sessions[_sessionId].winningProposals;\n    }\n\n    // ===============\n    // private functions\n    // ===============\n    function _registerProposal(uint _sessionId, string memory _description) private {\n        require(sessions[_sessionId].proposals.length < 2 ** 8 - 1, 'Too many proposals'); // limit total proposals count to 256\n        sessions[_sessionId].proposals.push(Proposal(_description, 0, msg.sender));\n        sessions[_sessionId].voters[msg.sender].nbProposals++;\n        uint8 proposalId = uint8(sessions[_sessionId].proposals.length - 1);\n        emit ProposalRegistered(_sessionId, proposalId, msg.sender, sessions[_sessionId].proposals[proposalId].description);\n    }\n}"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
